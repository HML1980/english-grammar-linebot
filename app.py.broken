# å‚™ä»½ç•¶å‰ç‰ˆæœ¬
cp app.py app.py.broken

# å»ºç«‹å…¨æ–°çš„ä¹¾æ·¨ç‰ˆæœ¬
cat > app.py << 'EOF'
# -*- coding: utf-8 -*-
import os
import json
import psycopg2
import psycopg2.pool
import psycopg2.extras
import requests
import time
import re
from urllib.parse import parse_qs
from flask import Flask, request, abort
from linebot.v3 import WebhookHandler
from linebot.v3.exceptions import InvalidSignatureError
from linebot.v3.messaging import (
    Configuration, ApiClient, MessagingApi,
    ReplyMessageRequest, TextMessage, ImageMessage, PostbackAction,
    TemplateMessage, ButtonsTemplate, CarouselTemplate, CarouselColumn,
    QuickReply, QuickReplyItem
)
from linebot.v3.webhooks import MessageEvent, TextMessageContent, PostbackEvent, FollowEvent

app = Flask(__name__)

DATABASE_URL = os.environ.get('DATABASE_URL')
if not DATABASE_URL:
    DATABASE_URL = 'postgresql://localhost/linebot'

connection_pool = psycopg2.pool.ThreadedConnectionPool(1, 20, DATABASE_URL)

def get_db_connection():
    return connection_pool.getconn()

def return_db_connection(conn):
    connection_pool.putconn(conn)

def init_database():
    conn = get_db_connection()
    try:
        cur = conn.cursor()
        cur.execute('''
            CREATE TABLE IF NOT EXISTS users (
                id SERIAL PRIMARY KEY,
                line_user_id TEXT UNIQUE NOT NULL,
                display_name TEXT,
                current_chapter_id INTEGER,
                current_section_id INTEGER,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        ''')
        cur.execute('''
            CREATE TABLE IF NOT EXISTS bookmarks (
                id SERIAL PRIMARY KEY,
                line_user_id TEXT NOT NULL,
                chapter_id INTEGER NOT NULL,
                section_id INTEGER NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                UNIQUE(line_user_id, chapter_id, section_id)
            )
        ''')
        cur.execute('''
            CREATE TABLE IF NOT EXISTS quiz_attempts (
                id SERIAL PRIMARY KEY,
                line_user_id TEXT NOT NULL,
                chapter_id INTEGER NOT NULL,
                section_id INTEGER NOT NULL,
                user_answer TEXT NOT NULL,
                is_correct BOOLEAN NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        ''')
        cur.execute('''
            CREATE TABLE IF NOT EXISTS user_actions (
                id SERIAL PRIMARY KEY,
                line_user_id TEXT NOT NULL,
                action_data TEXT NOT NULL,
                timestamp REAL NOT NULL
            )
        ''')
        conn.commit()
        print(">>> è³‡æ–™åº«åˆå§‹åŒ–å®Œæˆ")
    except Exception as e:
        conn.rollback()
        print(f">>> è³‡æ–™åº«åˆå§‹åŒ–éŒ¯èª¤: {e}")
    finally:
        return_db_connection(conn)

def is_duplicate_action(user_id, action_data, cooldown=2):
    return False

def check_new_user_guidance(user_id):
    return ""

CHANNEL_SECRET = os.environ.get('CHANNEL_SECRET')
CHANNEL_ACCESS_TOKEN = os.environ.get('CHANNEL_ACCESS_TOKEN')
MAIN_RICH_MENU_ID = os.environ.get('MAIN_RICH_MENU_ID')

print(">>> ç’°å¢ƒè®Šæ•¸æª¢æŸ¥:")
print(f"CHANNEL_SECRET: {'å·²è¨­å®š' if CHANNEL_SECRET else 'æœªè¨­å®š'}")
print(f"CHANNEL_ACCESS_TOKEN: {'å·²è¨­å®š' if CHANNEL_ACCESS_TOKEN else 'æœªè¨­å®š'}")
print(f"MAIN_RICH_MENU_ID: {'å·²è¨­å®š' if MAIN_RICH_MENU_ID else 'æœªè¨­å®š'}")

required_env_vars = [CHANNEL_SECRET, CHANNEL_ACCESS_TOKEN, MAIN_RICH_MENU_ID]
if not all(required_env_vars):
    print("éŒ¯èª¤ï¼šç¼ºå°‘å¿…è¦çš„ç’°å¢ƒè®Šæ•¸")
    exit(1)

configuration = Configuration(access_token=CHANNEL_ACCESS_TOKEN)
handler = WebhookHandler(CHANNEL_SECRET)

def load_book_data():
    try:
        with open('book.json', 'r', encoding='utf-8') as f:
            data = json.load(f)
        print(">>> book.json è¼‰å…¥æˆåŠŸ")
        return data
    except Exception as e:
        print(f">>> è¼‰å…¥ book.json å¤±æ•—: {e}")
        return {"chapters": []}

book_data = load_book_data()
init_database()

def switch_rich_menu(user_id, rich_menu_id):
    try:
        headers = {'Authorization': f'Bearer {CHANNEL_ACCESS_TOKEN}'}
        url = f'https://api.line.me/v2/bot/user/{user_id}/richmenu/{rich_menu_id}'
        response = requests.post(url, headers=headers, timeout=10)
        if response.status_code == 200:
            print(f">>> åœ–æ–‡é¸å–®åˆ‡æ›æˆåŠŸ: {rich_menu_id}")
            return True
        else:
            print(f">>> åˆ‡æ›å¤±æ•—: {response.status_code}")
            return False
    except Exception as e:
        print(f">>> åˆ‡æ›åœ–æ–‡é¸å–®éŒ¯èª¤: {e}")
        return False

@app.route("/callback", methods=['POST'])
def callback():
    signature = request.headers['X-Line-Signature']
    body = request.get_data(as_text=True)
    try:
        handler.handle(body, signature)
    except InvalidSignatureError:
        abort(400)
    except Exception as e:
        print(f">>> è™•ç†éŒ¯èª¤: {e}")
        abort(500)
    return 'OK'

@app.route("/health", methods=['GET'])
def health_check():
    return {"status": "healthy", "chapters": len(book_data.get('chapters', []))}

@app.route("/", methods=['GET'])
def index():
    return {"message": "LINE Bot is running", "status": "healthy"}

@handler.add(MessageEvent, message=TextMessageContent)
def handle_message(event):
    text = event.message.text.strip()
    user_id = event.source.user_id
    line_api = MessagingApi(ApiClient(configuration))
    try:
        if text == "1" or text == "é–±è®€å…§å®¹":
            handle_start_reading(user_id, event.reply_token, line_api)
        else:
            line_api.reply_message(
                ReplyMessageRequest(
                    reply_token=event.reply_token,
                    messages=[TextMessage(text="è¼¸å…¥ã€Œ1ã€é–‹å§‹ç¬¬ä¸€ç« ")]
                )
            )
    except Exception as e:
        print(f">>> è™•ç†æ–‡å­—è¨Šæ¯éŒ¯èª¤: {e}")

@handler.add(FollowEvent)
def handle_follow(event):
    user_id = event.source.user_id
    line_api = MessagingApi(ApiClient(configuration))
    try:
        conn = get_db_connection()
        cur = conn.cursor()
        cur.execute("INSERT INTO users (line_user_id, display_name) VALUES (%s, %s) ON CONFLICT (line_user_id) DO NOTHING", (user_id, "æ–°ç”¨æˆ¶"))
        conn.commit()
        return_db_connection(conn)
        switch_rich_menu(user_id, MAIN_RICH_MENU_ID)
        welcome_text = "æ­¡è¿ä½¿ç”¨äº”åˆ†é˜è‹±æ–‡æ–‡æ³•æ”»ç•¥ï¼\n\nè¼¸å…¥ã€Œ1ã€é–‹å§‹ç¬¬ä¸€ç« "
        line_api.reply_message(ReplyMessageRequest(reply_token=event.reply_token, messages=[TextMessage(text=welcome_text)]))
    except Exception as e:
        print(f">>> è™•ç†é—œæ³¨äº‹ä»¶éŒ¯èª¤: {e}")

@handler.add(PostbackEvent)
def handle_postback(event):
    data = event.postback.data
    reply_token = event.reply_token
    user_id = event.source.user_id
    line_api = MessagingApi(ApiClient(configuration))
    print(f">>> æ”¶åˆ°ä¾†è‡ª {user_id} çš„ Postback: {data}")
    try:
        if data.isdigit():
            chapter_number = int(data)
            handle_start_reading(user_id, reply_token, line_api)
        else:
            line_api.reply_message(ReplyMessageRequest(reply_token=reply_token, messages=[TextMessage(text="åŠŸèƒ½é–‹ç™¼ä¸­")]))
    except Exception as e:
        print(f">>> Postback è™•ç†éŒ¯èª¤: {e}")

def handle_start_reading(user_id, reply_token, line_api):
    try:
        chapter = next((ch for ch in book_data['chapters'] if ch['chapter_id'] == 1), None)
        if not chapter:
            line_api.reply_message(ReplyMessageRequest(reply_token=reply_token, messages=[TextMessage(text="ç¬¬ä¸€ç« å°šæœªé–‹æ”¾")]))
            return
        
        conn = get_db_connection()
        cur = conn.cursor()
        cur.execute("UPDATE users SET current_chapter_id = %s, current_section_id = %s WHERE line_user_id = %s", (1, 0, user_id))
        conn.commit()
        return_db_connection(conn)
        
        if chapter.get('image_url'):
            line_api.reply_message(
                ReplyMessageRequest(
                    reply_token=reply_token,
                    messages=[
                        ImageMessage(original_content_url=chapter['image_url'], preview_image_url=chapter['image_url']),
                        TextMessage(text=f"ğŸ“– {chapter['title']}\n\nç¬¬ 1 æ®µ (ç« ç¯€åœ–ç‰‡)")
                    ]
                )
            )
        else:
            line_api.reply_message(ReplyMessageRequest(reply_token=reply_token, messages=[TextMessage(text="é–‹å§‹é–±è®€ç¬¬ä¸€ç« ")]))
    except Exception as e:
        print(f">>> é–‹å§‹é–±è®€éŒ¯èª¤: {e}")
        line_api.reply_message(ReplyMessageRequest(reply_token=reply_token, messages=[TextMessage(text="é–‹å§‹é–±è®€å¤±æ•—ï¼Œè«‹ç¨å¾Œå†è©¦")]))

if __name__ == "__main__":
    print(">>> LINE Bot å•Ÿå‹•")
    print(f">>> è¼‰å…¥ {len(book_data.get('chapters', []))} ç« ç¯€")
    print(">>> PostgreSQLç‰ˆæœ¬ - æœ€å°åŒ–æ¸¬è©¦ç‰ˆ")
    app.run(host='0.0.0.0', port=8080, debug=False)
EOF

# æª¢æŸ¥èªæ³•
python -m py_compile app.py
echo "èªæ³•æª¢æŸ¥: $?"

# ç«‹å³éƒ¨ç½²æ¸¬è©¦
git add app.py
git commit -m "Clean minimal version to test PostgreSQL connection"
git push